今天目标：
	1. UnitTest框架基本使用
	2. Fixture
	3. 断言
	4. Html测试报告
一、UnitTest框架
	1.1 为什么使用UnitTest框架？
		1. 批量执行用例
		2. 提供丰富的断言知识
		3. 可以生成报告
		
	1.2 什么是UnitTest框架
		python自带一种单元测试框架
		
	1.3 核心要素
		1). TestCase（测试用例）
		2). TestSuite(测试套件)
		3). TextTestRunner(以文本的形式运行测试用例)
		4). TestLoader(批量执行测试用例-搜索指定文件夹内指定字母开头的模块) 【推荐】
		5). Fixture(固定装置(两个固定的函数，一个初始化时使用，一个结束时使用))
		
	TestCase：
		说明：测试用例
		步骤：
			1. 导包 import unittest
			2. 新建测试类并继承 unittest.TestCase
			3. 测试方法必须以test字母开头
		运行：
			1. 运行测试类所有的测试方法，光标定位到类当前行右键运行
			2. 运行单个测试方法：光标放到测试方法当前行。
	
	TestSuite:
		说明：测试套件 
		步骤： 
			1. 导包
			2. 获取测试套件对象 suite = unittest.TestSuite()
			3. 调用addTest()方法 添加测试用例
			
		添加测试用例方法： 
			1. suite.addTest(类名("方法名称")) # 添加指定类中指定的测试方法
			2. suite.addTest(unittest.makeSuite(类名)) # 添加指定类中所有已test开头的方法
	TextTestRunner:
		说明：执行测试套件方法
		步骤： 
			1. 导包
			2. 实例化后去执行套件对象 runner = unittest.TextTestRunner()
			3. 调用run方法去执行 runner.run(suite)
			
	TestLoader：
		说明：
			1. 将符合条件的测试方法添加到测试套件中
			2. 搜索指定目录文件下指定字母开头的模块文件下test开始的方法，并将这些方法添加到测试套件中，最后返回测试套件
		操作： 
			1. 导包
					import unittest
			2. 调用TestLoader()
					写法1. suite = unittest.TestLoader().discover("指定搜索的目录文件","指定字母开头模块文件")
					写法2. suite = unittest.defaultTestLoader.discover("指定搜索的目录文件","指定字母开头模块文件") 【推荐】
					注意：如果使用写法1，TestLoader()必须有括号。
			3. 执行测试套件
					unittest.TextTestRunner().run(suite)
					
	TestSuite与TestLoader区别：
		共同点：都是测试套件
		不同点：实现方式不同
			TestSuite: 要么添加指定的测试类中所有test开头的方法，要么添加指定测试类中指定某个test开头的方法
			TestLoader: 搜索指定目录下指定字母开头的模块文件中以test字母开头的方法并将这些方法添加到测试套件中，最后返回测试套件
			
二、fixture
	说明：装置函数(setUp、tearDown)
	级别：
		1). 函数级别 def setUp() / def tearDown()
				特性：几个测试函数，执行几次。每个测试函数执行之前都会执行 setUp，执行之后都会执行tearDwon
		2). 类级别 def setUpClass() / def tearDownClass()
				特性：测试类运行之前运行一次setUpClass 类运行之后运行一次tearDownClass
				注意：类方法必须使用 @classmethod修饰
		3). 模块级别：def setUpModule() / def tearDownModule()
				特殊：模块运行之前执行一次setUpModule ,运行之后运行一次tearDownModule
				
	提示：
		无论使用函数级别还是类级别，最后常用场景为：
			初始化：
				1. 获取浏览器实例化对象
				2. 最大化浏览器
				3. 隐式等待
			结束：
				关闭浏览器驱动对象
				
三、断言
	3.1 什么是断言？
		让程序代替人为判断执行结果是否与预期结果相等的过程
	3.2 为什么要断言？
		自动化脚本执行时都是无人值守，需要通过断言来判断自动化脚本的执行是否通过
		注：自动化脚本不写断言，相当于没有执行测试一个效果。
	3.3 常用断言
		1. self.assertEqual(ex1, ex2)  #判断ex1 是否相等ex2
		2. self.assertIn(ex1 ,ex2) # ex2是否包含ex1 注意：所谓的包含不能跳字符
		3. self.assertTrue(ex) # 判断ex是否为True
		
	3.4 断言练习
		目标：tpshop登录
		方法：
			def setUp():
				# 获取driver
				# 打开url
				# 最大化浏览器
				# 隐式等待
			def tearDown():
				# 关闭浏览器驱动
			
			def test_login_code_null():
				# 根据业务流程编写
				# ...
				# 失败截图
		
	3.5 扩展
		断言两种实现方式
			方式1：使用unittest框架中断言，详情请参考以上相关知识点。
			方式2：使用python自带断言
				1. assert str1 == str2 # 判断str1 是否与str2相等
				2. assert str1 in str2 # 判断str2 是否包含str1
				3. assert True/1 # 判断是否为True
				
四、参数化
	4.1 为什么要参数化
		解决冗余代码问题；
	4.2 什么是参数化
		说明：根据需求动态获取参数并引用的过程
	4.3 参数化应用场景
		场景：解决相同业务逻辑，不同测试数据问题。
		
	4.4 应用：
		1. 安装插件
			通过命令：
				安装：
					pip install parameterized
				验证：
					pip show parameterized
			通过pycharm:File-->setting-->Project 工程名称
			
		2. 应用插件
			1. 导包 from parameterized import parameterized
			2. 修饰测试函数 @parameterized.expand([数据])
				数据格式：
					1. 单个参数：类型为列表
					2. 多个参数：类型为列表嵌套元祖
					3. 在测试函数中的参数设置变量引用参数值，注意：变量的数量必须和数据值的个数相同
		
			
			
	